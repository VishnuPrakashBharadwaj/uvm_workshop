////----------------------------------------------------------------------
//// This file has been automatically generated by
//// VerifStudio Software Version 0.63, Accelver Systems Inc.
//// Any modifications that you make to this file may be
//// overwritten by the tool when regenerating the files. 
////----------------------------------------------------------------------

`ifndef AHB_MASTER_AGENT__SV
`define AHB_MASTER_AGENT__SV

class ahb_master_agent#(AHB_ADDR_WIDTH=16,AHB_DATA_WIDTH=16) extends uvm_agent;

    // Declare a Variable that will indicate if this Agent works in ACTIVE or PASSIVE mode.
    uvm_active_passive_enum is_active;

    // Declare a handle to the configdb object associated with this agent.
    ahb_master_config#(AHB_ADDR_WIDTH,AHB_DATA_WIDTH) config_db;

    // Declare a handle to the Driver, Monitor and Sequencer objects.
    ahb_master_driver#(AHB_ADDR_WIDTH,AHB_DATA_WIDTH) master_driver;
    ahb_master_monitor#(AHB_ADDR_WIDTH,AHB_DATA_WIDTH) master_monitor;
    ahb_master_sequencer#(AHB_ADDR_WIDTH,AHB_DATA_WIDTH) master_sequencer;

    // Register the class ahb_master_agent with the factory.
    `uvm_component_param_utils(ahb_master_agent#(AHB_ADDR_WIDTH,AHB_DATA_WIDTH))

    // The Constructor for this Class.
    function new(string name="ahb_master_agent", uvm_component parent);
        super.new(name, parent);
    endfunction: new

    // Declare the build phase of the UVM Agent.
    extern virtual function void build_phase(uvm_phase phase);

    // Declare the connect phase of the UVM Agent.
    extern virtual function void connect_phase(uvm_phase phase);

endclass: ahb_master_agent


// Define the build phase of the UVM Agent.
function void ahb_master_agent::build_phase(uvm_phase phase);

    super.build_phase(phase);

    `uvm_info(get_type_name(), "Inside the Build Phase of ahb_master_agent.", UVM_HIGH)

    // Get the config_object from the uvm_config_db.
    if(!uvm_config_db#(ahb_master_config#(AHB_ADDR_WIDTH,AHB_DATA_WIDTH))::get(this, "", "master_config_object", config_db))
    begin
        `uvm_fatal(get_type_name(), "The Configuration Object for the agent has not been set.")
    end

    // Get the is_active value from the config_object
    is_active = config_db.is_active;

    // Build the Driver and Sequencer only if the agent is active.
    if(is_active == UVM_ACTIVE)
    begin
        master_driver = ahb_master_driver#(AHB_ADDR_WIDTH,AHB_DATA_WIDTH)::type_id::create("master_driver", this);
        master_sequencer = ahb_master_sequencer#(AHB_ADDR_WIDTH,AHB_DATA_WIDTH)::type_id::create("master_sequencer", this);
    end

    // Build the Monitor regardless of whether agent is active or passive.
    master_monitor = ahb_master_monitor#(AHB_ADDR_WIDTH,AHB_DATA_WIDTH)::type_id::create("master_monitor", this);

endfunction: build_phase


// Define the connect phase of the UVM Agent.
function void ahb_master_agent::connect_phase(uvm_phase phase);

    super.connect_phase(phase);

    `uvm_info(get_type_name(), "Inside the Connect Phase of ahb_master_agent.", UVM_HIGH)

    // If the agent is active, then connect the driver's sequence item port to sequencer's sequence item export.
    if(is_active == UVM_ACTIVE)
    begin
        master_driver.seq_item_port.connect(master_sequencer.seq_item_export);
    end

endfunction: connect_phase



`endif